---
layout: layouts/post.njk
title: 'Progressive Web Apps in the HTTP Archive'
author: 'Thomas Steiner'
date: '2018-07-09T14:37:48'
permalink: 2018/07/09/progressive-web-apps-in-the-http-archive-143748/index.html
tags:
  - Technical
---

<p><strong>Thomas Steiner</strong>, Google Hamburg, Germany</p>
<p>
  üìß <a href="tomac@google.com">tomac@google.com</a> ‚Ä¢ üê¶
  <a href="https://twitter.com/tomayac">@tomayac</a> ‚Ä¢ üò∏
  <a href="https://github.com/tomayac">tomayac</a>
</p>
<h4><a></a><em>Abstract</em></h4>
<p>
  <em
    >In this document, we present three different approaches and discuss their
    particular pros and cons for extracting data about Progressive Web Apps
    (PWA) from the HTTP Archive. Approach&nbsp;1 is based on data that is
    tracked in the context of runs of the Lighthouse tool, Approach&nbsp;2 is
    based on use counters in the Chrome browser to record per-page anonymous
    aggregated metrics on feature usage, and Approach&nbsp;3 is based on parsing
    the source code of web pages for traces of service worker registrations and
    Web App Manifest references. We find that by all three approaches the
    popularity of PWAs increases roughly linearly over time and provide further
    research ideas based on the extracted data, whose underlying queries we
    share publicly.</em
  >
</p>
<h4><a></a>Introduction to Progressive Web Apps</h4>
<p>
  Progressive Web Apps (PWA) are a new class of web applications, enabled for
  the most part by the
  <a
    href="https://developer.mozilla.org/en/docs/Web/API/Service_Worker_API"
    rel="nofollow"
    >Service Worker APIs</a
  >. Service workers allow apps to support
  <em>network-independent loading</em> by intercepting network requests to
  deliver programmatic or cached responses, service workers can receive
  <em>push notifications</em> and <em>synchronize</em> data in the background
  even when the corresponding app is not running, and service workers‚Äîtogether
  with
  <a href="https://developer.mozilla.org/en-US/docs/Web/Manifest" rel="nofollow"
    >Web App Manifests</a
  >allow users to <em>install</em> PWAs to their devices' home screens. Service
  workers were
  <a
    href="https://blog.chromium.org/2014/12/chrome-40-beta-powerful-offline-and.html"
    rel="nofollow"
    >first implemented in Chrome 40 Beta</a
  >
  released in December 2014, and the term <em>Progressive Web Apps</em> was
  <a
    href="https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/"
    rel="nofollow"
    >coined by Frances Berriman and Alex Russell</a
  >
  in 2015.
</p>
<h4><a></a>Research Questions and Problem Statement</h4>
<p>
  As service workers are now finally
  <a href="https://jakearchibald.github.io/isserviceworkerready/" rel="nofollow"
    >implemented in all major browsers</a
  >, we at the Google Web Developer Relations team were wondering
  <em
    >how many PWAs are actually out there in the wild and how do they make use
    of these new technologies?</em
  >
  Certain advanced APIs like
  <a
    href="https://developers.google.com/web/updates/2015/12/background-sync"
    rel="nofollow"
    >Background Sync</a
  >
  are currently still
  <a href="https://caniuse.com/#feat=background-sync" rel="nofollow"
    >only available on Chromium-based browsers</a
  >, so as an additional question we looked into
  <em
    >what features do these PWAs actually use‚Äîor in the sense of progressive
    enhancement‚Äîtry to use?</em
  >
  Our first idea was to check some of the curated PWA catalogues, for example,
  <a href="https://pwa.rocks/" rel="nofollow">PWA.rocks</a>,
  <a href="https://pwa-directory.appspot.com/" rel="nofollow">PWA Directory</a>,
  <a href="https://outweb.io/" rel="nofollow">Outweb</a>, or
  <a href="https://www.pwastats.com/" rel="nofollow">PWA Stats</a>. The problem
  with such catalogues is that they suffer from what we call
  <em>submission bias</em>.
  <a href="https://outweb.io/1506520224205" rel="nofollow">Anecdotal</a>
  <a href="https://www.pwastats.com/2017/06/forbes/" rel="nofollow">evidence</a>
  <a
    href="https://pwa-directory.appspot.com/pwas/5758305695694848"
    rel="nofollow"
    >shows</a
  >
  that authors of PWAs want to be included in as many catalogues as possible,
  but oftentimes the listed examples are not very representative of
  <em>the</em> web and rather longtail. For example, at the time of writing, the
  <a
    href="https://pwa-directory.appspot.com/pwas/4816176644358144"
    rel="nofollow"
    >first listed PWA</a
  >
  on <em>PWA Directory</em> is
  <a href="https://feuerwehr-eisolzried.de/" rel="nofollow"
    >feuerwehr-eisolzried.de</a
  >, a PWA on the
  <em
    >"latest news, dates and more from [the] fire department in Eisolzried,
    Bavaria."</em
  >
  Second, while <em>PWA Stats</em> offers tags, for example, on the
  <a href="https://www.pwastats.com/tags/notifications" rel="nofollow"
    >use of notifications</a
  >, not all PWA features are classified in their tagging system. In short, PWA
  catalogues are not very well suited for answering our research questions.
</p>
<h4><a></a>The HTTP Archive to the Rescue</h4>
<p>
  The <a href="https://httparchive.org/" rel="nofollow">HTTP Archive</a> tracks
  how the web is built and provides historical data to quantitatively illustrate
  how the web is evolving. The archive's crawlers process
  <a
    href="https://httparchive.org/faq#how-does-the-http-archive-decide-which-urls-to-test"
    rel="nofollow"
    >500,000 URLs</a
  >
  for both desktop and mobile twice a month. These URLs come from the most
  popular 500,000 sites in the
  <a href="http://www.alexa.com/topsites" rel="nofollow">Alexa Top 1,000,000</a>
  list and are mostly homepages that may or may not be representative for the
  rest of the site. The data in the HTTP Archive can be
  <a
    href="https://github.com/HTTPArchive/legacy.httparchive.org/blob/master/docs/bigquery-gettingstarted.md"
    >queried through BigQuery</a
  >, where multiple tables are available in the
  <code>httparchive</code> project. As these tables tend to get fairly big, they
  are partitioned, but multiple associated tables can be queried using the
  <a
    href="https://cloud.google.com/bigquery/docs/querying-wildcard-tables"
    rel="nofollow"
    >wildcard symbol '*'</a
  >. For our purposes, three families of tables are relevant, leading to three
  different approaches:
</p>
<ul>
  <li>
    <code>httparchive.lighthouse.*</code>, which contains data about
    <a href="https://developers.google.com/web/tools/lighthouse/" rel="nofollow"
      >Lighthouse</a
    >
    runs.
  </li>
  <li>
    <code>httparchive.pages.*</code>, which contain the JSON-encoded parent
    documents'
    <a
      href="https://w3c.github.io/web-performance/specs/HAR/Overview.html"
      rel="nofollow"
      >HAR</a
    >
    data.
  </li>
  <li>
    <code>httparchive.response_bodies.*</code>, which contains the raw response
    bodies of all resources and sub-resources of all sites in the archive.
  </li>
</ul>
<p>
  In the following, we will discuss all three approaches and their particular
  pros and cons, as well as present the extractable data and ideas for further
  research. All
  <a href="https://github.com/tomayac/http-archive-progressive-web-apps"
    >queries are also available on GitHub</a
  >
  and are released under the terms of the Apache 2.0 license.
</p>
<p>
  <strong>‚ö†Ô∏è Warning:</strong>
  while BigQuery grants everyone a certain amount of
  <a href="https://cloud.google.com/bigquery/pricing#free" rel="nofollow"
    >free quota per month</a
  >, on-demand pricing kicks in once the free quota is consumed. Currently, this
  is
  <a
    href="https://cloud.google.com/bigquery/pricing#on_demand_pricing"
    rel="nofollow"
    >$5 per terabyte</a
  >. Some of the shown queries process 70+(!)&nbsp;terabytes! You can see the
  amount of data that will be processed by clicking on the
  <em>Validator</em> icon:
</p>
<p>
  <a href="/images/image_0.png" target="_blank"
    ><img
      width="1532"
      height="182"
      src="/images/image_0.png"
      alt="Notice of the amount of to-be-processed data"
  /></a>
</p>
<h4><a></a>Approach 1: <code>httparchive.lighthouse.*</code> Tables</h4>
<h5><a></a>Description</h5>
<p>
  <a href="https://developers.google.com/web/tools/lighthouse/" rel="nofollow"
    >Lighthouse</a
  >
  is an automated open-source tool for improving the quality of web pages. One
  can run it against any web page, public or requiring authentication. It has
  audits for <em>Performance</em>, <em>Accessibility</em>,
  <em>Progressive Web App</em>, and more. The
  <code>httparchive.lighthouse.*</code> tables contain JSON dumps (<a
    href="https://gist.github.com/tomayac/05fed2d4bfa94fe066c705510a3c2103"
    >example</a
  >) of past reports that can be extracted via BigQuery.
</p>
<h5><a></a>Cons</h5>
<p>
  The biggest con is that obviously the tables only contain data of web pages
  that were ever run through the tool, so there is a blind spot. Additionally,
  while latest versions of Lighthouse process mobile <em>and</em> desktop pages,
  the currently used Lighthouse only processes mobile pages, so there are no
  results for desktop. One pitfall when working with these tables is that in a
  past version of Lighthouse <em>Progressive Web App</em> was the first category
  that was shown in the tool, however the
  <a href="https://github.com/GoogleChrome/lighthouse/issues/3599"
    >order was flipped</a
  >
  in the current version so that now <em>Performance</em> is first. In the query
  we need to take this corner case into account.
</p>
<h5><a></a>Pros</h5>
<p>
  On the positive side, Lighthouse has clear scoring guidelines based on the
  <a
    href="https://developers.google.com/web/progressive-web-apps/checklist#baseline"
    rel="nofollow"
    >Baseline PWA Checklist</a
  >
  for each version of the tool (<a
    href="https://developers.google.com/web/tools/lighthouse/scoring#pwa"
    rel="nofollow"
    >v2</a
  >,
  <a
    href="https://developers.google.com/web/tools/lighthouse/v3/scoring#pwa"
    rel="nofollow"
    >v3</a
  >), so by requiring a minimum <em>Progressive Web App</em> score of ‚â•75, we
  can, to some extent, determine what PWA features we want to have included,
  namely, we can require offline capabilities and make sure the app can be added
  to the home screen.
</p>
<h5><a></a>Query and Results</h5>
<p>
  Running the query below and then selecting distinct PWA URLs returns
  <a
    href="https://docs.google.com/spreadsheets/d/1zxpfuEW06oG6wXWq96Zrs0FjzDVVDUTpRcNu9TkiyIw/edit?usp=sharing"
    rel="nofollow"
    >799 unique PWA results</a
  >
  that are known to work offline and to be installable to the user's home
  screen.
</p>
<div>
  <pre><span><span>#</span>standardSQL</span>
CREATE TEMPORARY FUNCTION
  getPWAScore(report STRING)
  RETURNS FLOAT64
  LANGUAGE js <span>AS</span> <span><span>"</span><span>"</span><span>"</span></span>
<span>$=JSON.parse(report);</span>
<span>return $.reportCategories.find(i =&gt; i.name === 'Progressive Web App').score;</span>
<span><span>"</span><span>"</span><span>"</span></span>;
<span>CREATE</span> <span>TABLE</span> <span>IF</span> NOT EXISTS
  <span><span>`</span>progressive_web_apps.lighthouse_pwas<span>`</span></span> <span>AS</span>
<span>SELECT</span>
  DISTINCT url <span>AS</span> pwa_url,
  IFNULL(rank,
    <span>1000000</span>) <span>AS</span> rank,
  <span>date</span>,
  platform,
  CAST(ROUND(score) <span>AS</span> INT64) <span>AS</span> lighthouse_pwa_score
<span>FROM</span> (
  <span>SELECT</span>
    REGEXP_REPLACE(JSON_EXTRACT(report,
        <span><span>"</span>$.url<span>"</span></span>), <span><span>"</span><span>"</span><span>"</span>, <span>"</span><span>"</span>) AS url,</span>
<span>    getPWAScore(report) AS score,</span>
<span>    REGEXP_REPLACE(REGEXP_EXTRACT(_TABLE_SUFFIX, <span>"</span></span>\d{<span>4</span>}(?:_\d{<span>2</span>}){<span>2</span>}<span><span>"</span>), <span>"</span></span>_<span><span>"</span>, <span>"</span></span><span>-</span><span><span>"</span>) AS date,</span>
<span>    REGEXP_EXTRACT(_TABLE_SUFFIX, <span>"</span></span>.<span>*</span>_(\w<span>+</span>)$<span><span>"</span>) AS platform</span>
<span>  FROM</span>
<span>    `httparchive.lighthouse.*`</span>
<span>  WHERE</span>
<span>    report IS NOT NULL</span>
<span>    AND JSON_EXTRACT(report,</span>
<span>      <span>"</span></span>$.<span>audits</span>.<span>service</span><span>-</span><span>worker</span>.<span>score</span><span><span>"</span>) = 'true' )</span>
<span>LEFT JOIN (</span>
<span>  SELECT</span>
<span>    Alexa_rank AS rank,</span>
<span>    Alexa_domain AS domain</span>
<span>  FROM</span>
<span>    # Hard-coded due to https://github.com/HTTPArchive/bigquery/issues/42</span>
<span>    `httparchive.urls.20170315`</span>
<span>  WHERE</span>
<span>    Alexa_rank IS NOT NULL</span>
<span>    AND Alexa_domain IS NOT NULL ) AS urls</span>
<span>ON</span>
<span>  urls.domain = NET.REG_DOMAIN(url)</span>
<span>WHERE</span>
<span>  # Lighthouse <span>"</span></span>Good<span><span>"</span> threshold</span>
<span>  score &gt;= 75</span>
<span>GROUP BY</span>
<span>  url,</span>
<span>  date,</span>
<span>  score,</span>
<span>  platform,</span>
<span>  date,</span>
<span>  rank</span>
<span>ORDER BY</span>
<span>  rank ASC,</span>
<span>  url,</span>
<span>  date DESC;</span></pre>
</div>
<h5><a></a>Research Ideas</h5>
<p>
  An interesting analysis we can run based on this data is the development of
  average Lighthouse PWA scores over time and the number of PWAs (note that the
  presented naive approach does not take the in relation also growing HTTP
  Archive into account, but purely counts absolute numbers).
</p>
<div>
  <pre><span><span>#</span>standardSQL</span>
<span>SELECT</span>
  <span>date</span>,
  <span>count</span> (DISTINCT pwa_url) <span>AS</span> total_pwas,
  round(<span>AVG</span>(lighthouse_pwa_score), <span>1</span>) <span>AS</span> avg_lighthouse_pwa_score
<span>FROM</span>
  <span><span>`</span>progressive_web_apps.lighthouse_pwas<span>`</span></span>
<span>GROUP BY</span>
  <span>date</span>
<span>ORDER BY</span>
  <span>date</span>;</pre>
</div>
<p>
  <a href="/images/image_1.png" target="_blank"
    ><img
      width="1200"
      height="742"
      src="/images/image_1.png"
      alt="Average PWA scores over time, the trend is going up from ~83 (of 100) in June 2017 to ~85 (of 100) in May 2018"
  /></a>
</p>
<p>
  <a href="/images/image_2.png" target="_blank"
    ><img
      width="1200"
      height="742"
      src="/images/image_2.png"
      alt="Number of PWAs over time, the trend is going up from ~100 in June 2017 to ~340 in May 2018"
  /></a>
</p>
<h4><a></a>Approach 2: <code>httparchive.pages.*</code> Tables</h4>
<h5><a></a>Description</h5>
<p>
  Another straightforward way for estimating the amount of PWAs (however
  completely neglecting Web App Manifests) is to look for so-called
  <a
    href="https://cs.chromium.org/chromium/src/third_party/blink/public/mojom/web_feature/web_feature.mojom"
    rel="nofollow"
    >use counters</a
  >
  in the <code>httparchive.pages.*</code> tables. Particularly interesting is
  the <code>ServiceWorkerControlledPage</code> use counter, which,
  <a
    href="https://groups.google.com/a/chromium.org/d/msg/blink-api-owners-discuss/uxwEuxCRfGA/_1VdL4_EBAAJ"
    rel="nofollow"
    >according to Chrome engineer Matt Falkenhagen</a
  >,
  <em
    >is counted whenever a page is controlled by a service worker, which
    typically happens only on subsequent loads.</em
  >
</p>
<h5><a></a>Cons</h5>
<p>
  No qualitative attributes other than the absolute fact that a service worker
  controlled the loading of the page can be extracted. More importantly, as the
  counter is typically triggered on subsequent loads only (and not on the first
  load that the crawler sees), this method undercounts and only contains sites
  that claim their clients (<code>self.clients.claim()</code>) on the first
  load.
</p>
<h5><a></a>Pros</h5>
<p>
  On the bright side, the precision is high due to the browser-level tracking,
  so we can be sure the page actually registered a service worker. The query
  also covers both desktop and mobile.
</p>
<h5><a></a>Query and Results</h5>
<p>
  This approach, at time of writing, turns up
  <a
    href="https://docs.google.com/spreadsheets/d/16jJQF4ACqOKnypCC1jqUqpC3mO-guBZAaSA-P9tbJJg/edit?usp=sharing"
    rel="nofollow"
    >5,368 unique results</a
  >, however, as mentioned before, not all of these results
  <em>necessarily</em> qualify as PWA due to the potentially missing Web App
  Manifest that affects the installability of the app.
</p>
<div>
  <pre><span><span>#</span>standardSQL</span>
<span>CREATE</span> <span>TABLE</span> <span>IF</span> NOT EXISTS
  <span><span>`</span>progressive_web_apps.usecounters_pwas<span>`</span></span> <span>AS</span>
<span>SELECT</span>
  DISTINCT REGEXP_REPLACE(url, <span><span>"</span>^http:<span>"</span></span>, <span><span>"</span>https:<span>"</span></span>) <span>AS</span> pwa_url,
  IFNULL(rank,
    <span>1000000</span>) <span>AS</span> rank,
  <span>date</span>,
  platform
<span>FROM</span> (
  <span>SELECT</span>
    DISTINCT url,
    REGEXP_REPLACE(REGEXP_EXTRACT(_TABLE_SUFFIX, <span><span>"</span>\d{4}(?:_\d{2}){2}<span>"</span></span>), <span><span>"</span>_<span>"</span></span>, <span><span>"</span>-<span>"</span></span>) <span>AS</span> <span>date</span>,
    REGEXP_EXTRACT(_TABLE_SUFFIX, <span><span>"</span>.*_(\w+)$<span>"</span></span>) <span>AS</span> platform
  <span>FROM</span>
    <span><span>`</span>httparchive.pages.*<span>`</span></span>
  <span>WHERE</span>
    <span><span>#</span> From https://cs.chromium.org/chromium/src/third_party/blink/public/mojom/web_feature/web_feature.mojom</span>
    JSON_EXTRACT(payload,
      <span><span>'</span>$._blinkFeatureFirstUsed.Features.ServiceWorkerControlledPage<span>'</span></span>) <span>IS NOT NULL</span>)
<span>LEFT JOIN</span> (
  <span>SELECT</span>
    Alexa_domain <span>AS</span> domain,
    Alexa_rank <span>AS</span> rank
  <span>FROM</span>
    <span><span>#</span> Hard-coded due to https://github.com/HTTPArchive/bigquery/issues/42</span>
    <span><span>`</span>httparchive.urls.20170315<span>`</span></span> <span>AS</span> urls
  <span>WHERE</span>
    Alexa_rank <span>IS NOT NULL</span>
    <span>AND</span> Alexa_domain <span>IS NOT NULL</span> )
<span>ON</span>
  domain <span>=</span> <span>NET</span>.<span>REG_DOMAIN</span>(url)
<span>ORDER BY</span>
  rank <span>ASC</span>,
  <span>date</span> <span>DESC</span>,
  pwa_url;</pre>
</div>
<h5><a></a>Research Ideas</h5>
<p>
  Similar to the second query in <em>Approach&nbsp;1</em> from above, we can
  also track the number of pages controlled by a service worker over time (the
  gap in the September 1, 2017 dataset is due to a parsing issue in the data
  collection pipeline).
</p>
<div>
  <pre><span><span>#</span>standardSQL</span>
<span>SELECT</span>
  <span>date</span>,
  <span>count</span> (DISTINCT pwa_url) <span>AS</span> total_pwas
<span>FROM</span>
  <span><span>`</span>progressive_web_apps.usecounters_pwas<span>`</span></span>
<span>GROUP BY</span>
  <span>date</span>
<span>ORDER BY</span>
  <span>date</span>;</pre>
</div>
<p>
  <a href="/images/image_3.png" target="_blank"
    ><img
      width="1200"
      height="742"
      src="/images/image_3.png"
      alt="Number of pages controlled by a service worker over time, the trend is going up from ~100 in December 2016 to ~2,000 in June 2018"
  /></a>
</p>
<h4><a></a>Approach 3: <code>httparchive.response_body.*</code> Tables</h4>
<h5><a></a>Description</h5>
<p>
  A third less obvious way to answer our research questions is to look at actual
  response bodies. The <code>httparchive.response_bodies.*</code> tables contain
  raw data of all resources and sub-resources of all sites in the archive, so we
  can use fulltext search to find patterns that are indicators for the presence
  of PWA features like, for instance, the existence of variations of the string
  <code>navigator.serviceWorker.register("</code> that provide a clue that the
  page might be registering a service worker on the one hand, and variations of
  <code>&lt;link rel="manifest"</code> that point to a potential Web App
  Manifest on the other hand.
</p>
<h5><a></a>Cons</h5>
<p>
  The downside of this approach is that we are trying to parse HTML with regular
  expressions to begin with, which is
  <a href="https://stackoverflow.com/a/1732454" rel="nofollow"
    >commonly known to be impossible</a
  >
  and a
  <a
    href="https://www.reddit.com/r/ProgrammerHumor/comments/6ytfw5/parsing_html_using_regular_expressions/"
    rel="nofollow"
    >bad practice</a
  >. One example where things can go wrong is that we might detect out-commented
  code or struggle with incorrectly nested code.
</p>
<h5><a></a>Pros</h5>
<p>
  Despite all challenges, as the service worker JavaScript files and the Web App
  Manifest JSON files are subresources of the page and therefore stored in the
  <code>httparchive.response_bodies.*</code> tables, we can still bravely
  attempt to examine their contents and try to gain an in-depth understanding of
  the PWAs' capabilities. By checking the service worker JavaScript code for the
  events the service worker listens to, we can see if a PWA‚Äîat least in
  theory‚Äîdeals with Web Push notifications, handles fetches, <em>etc.</em>, and
  by looking at the Web App Manifest JSON document, we can see if the PWA
  specifies a start URL, provides a name, and so on.
</p>
<h5><a></a>Query and Results</h5>
<p>
  We have split the analysis of service workers and Web App Manifests, and use a
  common helper table to extract PWA candidates from the large response body
  tables. As references to service worker script files and Web App Manifest JSON
  files may be relative or absolute, we need a
  <a
    href="https://cloud.google.com/bigquery/docs/reference/standard-sql/user-defined-functions"
    rel="nofollow"
    >User-Defined Function</a
  >
  to resolve paths like <code>../../manifest.json</code> relative to their base
  URL. Our function is a hacky simplification based on
  <a
    href="https://nodejs.org/docs/latest/api/path.html#path_path_resolve_paths"
    rel="nofollow"
    >path.resolve([...paths])</a
  >
  in Node.js and not very elegant. We deliberately ignore references that would
  require executing JavaScript, for example, URLs like
  <code>window.location.href + 'sw.js'</code>, so our regular expressions are a
  bit involved to make sure we exclude these cases.
</p>
<h6><a></a>PWA Candidates Helper Table</h6>
<div>
  <pre><span><span>#</span>standardSQL</span>
CREATE TEMPORARY FUNCTION
  pathResolve(path1 STRING,
    path2 STRING)
  RETURNS STRING
  LANGUAGE js <span>AS</span> <span><span>"</span><span>"</span><span>"</span></span>
<span>  function normalizeStringPosix(e,t){for(var n="",r=-1,i=0,l=void 0,o=!1,h=0;h&lt;=e.length;++h){if(h&lt;e.length)l=e.charCodeAt(h);else{if(l===SLASH)break;l=SLASH}if(l===SLASH){if(r===h-1||1===i);else if(r!==h-1&amp;&amp;2===i){if(n.length&lt;2||!o||n.charCodeAt(n.length-1)!==DOT||n.charCodeAt(n.length-2)!==DOT)if(n.length&gt;2){for(var g=n.length-1,a=g;a&gt;=0&amp;&amp;n.charCodeAt(a)!==SLASH;--a);if(a!==g){n=-1===a?"":n.slice(0,a),r=h,i=0,o=!1;continue}}else if(2===n.length||1===n.length){n="",r=h,i=0,o=!1;continue}t&amp;&amp;(n.length&gt;0?n+="/..":n="..",o=!0)}else{var f=e.slice(r+1,h);n.length&gt;0?n+="/"+f:n=f,o=!1}r=h,i=0}else l===DOT&amp;&amp;-1!==i?++i:i=-1}return n}function resolvePath(){for(var e=[],t=0;t&lt;arguments.length;t++)e[t]=arguments[t];for(var n="",r=!1,i=void 0,l=e.length-1;l&gt;=-1&amp;&amp;!r;l--){var o=void 0;l&gt;=0?o=e[l]:(void 0===i&amp;&amp;(i=getCWD()),o=i),0!==o.length&amp;&amp;(n=o+"/"+n,r=o.charCodeAt(0)===SLASH)}return n=normalizeStringPosix(n,!r),r?"/"+n:n.length&gt;0?n:"."}var SLASH=47,DOT=46,getCWD=function(){return""};if(/^https?:/.test(path2)){return path2;}if(/^\//.test(path2)){return path1+path2.substr(1);}return resolvePath(path1, path2).replace(/^(https?:\/)/, '$1/');</span>
<span><span>"</span><span>"</span><span>"</span></span>;
<span>CREATE</span> <span>TABLE</span> <span>IF</span> NOT EXISTS
  <span><span>`</span>progressive_web_apps.pwa_candidates<span>`</span></span> <span>AS</span>
<span>SELECT</span>
  DISTINCT REGEXP_REPLACE(page, <span><span>"</span>^http:<span>"</span></span>, <span><span>"</span>https:<span>"</span></span>) <span>AS</span> pwa_url,
  IFNULL(rank,
    <span>1000000</span>) <span>AS</span> rank,
  pathResolve(REGEXP_REPLACE(page, <span><span>"</span>^http:<span>"</span></span>, <span><span>"</span>https:<span>"</span></span>),
    REGEXP_EXTRACT(body, <span><span>"</span>navigator\.serviceWorker\.register\s*\(\s*[<span>"</span></span><span><span>'</span>]([^<span>\</span>),<span>\</span>s<span>"</span><span>'</span></span>]<span>+</span>)<span><span>"</span>)) AS sw_url,</span>
<span>  pathResolve(REGEXP_REPLACE(page, <span>"</span></span>^http:<span><span>"</span>, <span>"</span></span>https:<span><span>"</span>),</span>
<span>    REGEXP_EXTRACT(REGEXP_EXTRACT(body, <span>"</span></span>(<span>&lt;</span>link[^<span>&gt;</span>]<span>+</span>rel<span>=</span>[<span><span>"</span>']?manifest[<span>"</span></span><span><span>'</span>]?[^&gt;]+&gt;)"), "href=[<span>"</span><span>'</span></span>]?([^\s<span><span>"</span>'&gt;]+)[<span>"</span></span><span><span>'</span>]?")) AS manifest_url</span>
<span>FROM</span>
<span>  `httparchive.response_bodies.*`</span>
<span>LEFT JOIN (</span>
<span>  SELECT</span>
<span>    Alexa_domain AS domain,</span>
<span>    Alexa_rank AS rank</span>
<span>  FROM</span>
<span>    # Hard-coded due to https://github.com/HTTPArchive/bigquery/issues/42</span>
<span>    `httparchive.urls.20170315` AS urls</span>
<span>  WHERE</span>
<span>    Alexa_rank IS NOT NULL</span>
<span>    AND Alexa_domain IS NOT NULL )</span>
<span>ON</span>
<span>  domain = NET.REG_DOMAIN(page)</span>
<span>WHERE</span>
<span>  (REGEXP_EXTRACT(body, "navigator<span>\</span>.serviceWorker<span>\</span>.register<span>\</span>s*<span>\</span>(<span>\</span>s*[<span>"</span><span>'</span></span>]([^\),\s<span><span>"</span>']+)<span>"</span></span>) <span>IS NOT NULL</span>
    <span>AND</span> REGEXP_EXTRACT(body, <span><span>"</span>navigator\.serviceWorker\.register\s*\(\s*[<span>"</span></span><span><span>'</span>]([^<span>\</span>),<span>\</span>s<span>"</span><span>'</span></span>]<span>+</span>)<span><span>"</span>) != <span>"</span></span><span>/</span><span><span>"</span>)</span>
<span>  AND (REGEXP_EXTRACT(REGEXP_EXTRACT(body, <span>"</span></span>(<span>&lt;</span>link[^<span>&gt;</span>]<span>+</span>rel<span>=</span>[<span><span>"</span>']?manifest[<span>"</span></span><span><span>'</span>]?[^&gt;]+&gt;)"), "href=[<span>"</span><span>'</span></span>]?([^\s<span><span>"</span>'&gt;]+)[<span>"</span></span><span><span>'</span>]?") IS NOT NULL</span>
<span>    AND REGEXP_EXTRACT(REGEXP_EXTRACT(body, "(&lt;link[^&gt;]+rel=[<span>"</span><span>'</span></span>]?manifest[<span><span>"</span>']?[^&gt;]+&gt;)<span>"</span></span>), <span><span>"</span>href=[<span>"</span></span><span><span>'</span>]?([^<span>\</span>s<span>"</span><span>'</span></span><span>&gt;</span>]<span>+</span>)[<span><span>"</span>']?<span>"</span></span>) <span>!=</span> <span><span>"</span>/<span>"</span></span>)
<span>ORDER BY</span>
  rank <span>ASC</span>,
  pwa_url;</pre>
</div>
<h6><a></a>Web App Manifests Analysis</h6>
<p>
  Based on this helper table, we can then run the analysis of the Web App
  Manifests. We check for the existence of properties defined in the
  <a
    href="https://www.w3.org/TR/appmanifest/#webappmanifest-dictionary"
    rel="nofollow"
    ><code>WebAppManifest</code> dictionary</a
  >
  combined with non-standard, but well-known properties like
  <code>"gcm_sender_id"</code> from the deprecated
  <a href="https://developers.google.com/cloud-messaging/" rel="nofollow"
    >Google Cloud Messaging</a
  >
  or <code>"share_target"</code> from the currently
  <a
    href="https://wicg.github.io/web-share-target/#extension-to-the-web-app-manifest"
    rel="nofollow"
    >in flux Web Share Target API</a
  >. Turns out, not many manifests are in the archive; from 2,823 candidate
  manifest URLs in the helper table we actually only find
  <a
    href="https://docs.google.com/spreadsheets/d/1VE9hoj7Ag7E3kOG4BKc8NKISg1w0BZVQkGdCq4MJ6hw/edit?usp=sharing"
    rel="nofollow"
    >30 unique Web App Manifests</a
  >
  and thus PWAs in the response bodies, but these at least archived in several
  versions.
</p>
<div>
  <pre><span><span>#</span>standardSQL</span>
  <span>CREATE</span> <span>TABLE</span> <span>IF</span> NOT EXISTS <span><span>`</span>progressive_web_apps.web_app_manifests<span>`</span></span> <span>AS</span>
<span>SELECT</span>
  pwa_url,
  rank,
  manifest_url,
  <span>date</span>,
  platform,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>dir<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> dir_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>lang<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> lang_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>name<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> name_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>short_name<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> short_name_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>description<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> description_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>scope<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> scope_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>icons<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> icons_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>display<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> display_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>orientation<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> orientation_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>start_url<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> start_url_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>serviceworker<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> serviceworker_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>theme_color<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> theme_color_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>related_applications<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> related_applications_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>prefer_related_applications<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> prefer_related_applications_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>background_color<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> background_color_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>categories<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> categories_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>screenshots<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> screenshots_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>iarc_rating_id<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> iarc_rating_id_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>gcm_sender_id<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> gcm_sender_id_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>gcm_user_visible_only<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> gcm_user_visible_only_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>share_target<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> share_target_property,
  REGEXP_CONTAINS(manifest_code,
    r<span><span>"</span><span>"</span></span>supports_share<span><span>"</span>s*:<span>"</span></span>) <span>AS</span> supports_share_property
<span>FROM</span>
  <span><span>`</span>progressive_web_apps.pwa_candidates<span>`</span></span>
<span>JOIN</span> (
  <span>SELECT</span>
    url,
    body <span>AS</span> manifest_code,
    REGEXP_REPLACE(REGEXP_EXTRACT(_TABLE_SUFFIX, <span><span>"</span>\d{4}(?:_\d{2}){2}<span>"</span></span>), <span><span>"</span>_<span>"</span></span>, <span><span>"</span>-<span>"</span></span>) <span>AS</span> <span>date</span>,
    REGEXP_EXTRACT(_TABLE_SUFFIX, <span><span>"</span>.*_(\w+)$<span>"</span></span>) <span>AS</span> platform
  <span>FROM</span>
    <span><span>`</span>httparchive.response_bodies.*<span>`</span></span>
  <span>WHERE</span>
    body <span>IS NOT NULL</span>
    <span>AND</span> body <span>!=</span> <span><span>"</span><span>"</span></span>
    <span>AND</span> url <span>IN</span> (
    <span>SELECT</span>
      DISTINCT manifest_url
    <span>FROM</span>
      <span><span>`</span>progressive_web_apps.pwa_candidates<span>`</span></span>) ) <span>AS</span> manifest_bodies
<span>ON</span>
  <span>manifest_bodies</span>.<span>url</span> <span>=</span> manifest_url
<span>ORDER BY</span>
  rank <span>ASC</span>,
  pwa_url,
  <span>date</span> <span>DESC</span>,
  platform,
  manifest_url;</pre>
</div>
<h6><a></a>Research Ideas</h6>
<p>
  With this data at hand, we can extract all (well, not really <em>all</em>, but
  all known according to our query) PWAs that still use the deprecated Google
  Cloud Messaging service.
</p>
<div>
  <pre><span><span>#</span>standardSQL</span>
<span>SELECT</span>
  DISTINCT pwa_url,
  manifest_url
<span>FROM</span>
  <span><span>`</span>progressive_web_apps.web_app_manifests<span>`</span></span>
<span>WHERE</span>
  gcm_sender_id_property;</pre>
</div>
<h6><a></a>Service Workers Analysis</h6>
<p>
  Similarly to the analysis of Web App Manifests, the analysis of the various
  <a
    href="https://www.w3.org/TR/service-workers-1/#execution-context-events"
    rel="nofollow"
    ><code>ServiceWorkerGlobalScope</code> events </a
  >is based on regular expressions. Events can be listened to using two
  JavaScript syntaxes: <em>(i)</em> the property syntax (<em>e.g.</em>,
  <code>self.oninstall = [‚Ä¶]</code> or <em>(ii)</em> the event listener syntax
  (<em>e.g.</em>, <code>self.addEventListener('install', [‚Ä¶])</code>). As an
  additional data point, we extract potential uses of the increasingly popular
  library
  <a href="https://developers.google.com/web/tools/workbox/" rel="nofollow"
    >Workbox</a
  >
  by looking for telling traces of various Workbox versions in the code. Running
  this query we obtain
  <a
    href="https://docs.google.com/spreadsheets/d/1rrSh3tXje9WnySfX8oRafY7Aduunv6X0rq_jmcBicIM/edit?usp=sharing"
    rel="nofollow"
    >1,151 unique service workers</a
  >
  and thus PWAs.
</p>
<div>
  <pre><span><span>#</span>standardSQL</span>
<span>CREATE</span> <span>TABLE</span> <span>IF</span> NOT EXISTS
  <span><span>`</span>progressive_web_apps.service_workers<span>`</span></span> <span>AS</span>
<span>SELECT</span>
  pwa_url,
  rank,
  sw_url,
  <span>date</span>,
  platform,
  REGEXP_CONTAINS(sw_code, r<span><span>"</span>.oninstalls*=|addEventListener(s*[<span>"</span></span><span><span>'</span>]install[<span>"</span><span>'</span></span>]<span><span>"</span>) AS install_event,</span>
<span>  REGEXP_CONTAINS(sw_code, r<span>"</span></span>.onactivates<span>*</span><span>=</span>|addEventListener(s<span>*</span>[<span><span>"</span>']activate[<span>"</span></span><span><span>'</span>]") AS activate_event,</span>
<span>  REGEXP_CONTAINS(sw_code, r"<span>.</span>onfetch<span>s</span>*=|addEventListener<span>(s</span>*[<span>"</span><span>'</span></span>]fetch[<span><span>"</span>']<span>"</span></span>) <span>AS</span> fetch_event,
  REGEXP_CONTAINS(sw_code, r<span><span>"</span>.onpushs*=|addEventListener(s*[<span>"</span></span><span><span>'</span>]push[<span>"</span><span>'</span></span>]<span><span>"</span>) AS push_event,</span>
<span>  REGEXP_CONTAINS(sw_code, r<span>"</span></span>.onnotificationclicks<span>*</span><span>=</span>|addEventListener(s<span>*</span>[<span><span>"</span>']notificationclick[<span>"</span></span><span><span>'</span>]") AS notificationclick_event,</span>
<span>  REGEXP_CONTAINS(sw_code, r"<span>.</span>onnotificationclose<span>s</span>*=|addEventListener<span>(s</span>*[<span>"</span><span>'</span></span>]notificationclose[<span><span>"</span>']<span>"</span></span>) <span>AS</span> notificationclose_event,
  REGEXP_CONTAINS(sw_code, r<span><span>"</span>.onsyncs*=|addEventListener(s*[<span>"</span></span><span><span>'</span>]sync[<span>"</span><span>'</span></span>]<span><span>"</span>) AS sync_event,</span>
<span>  REGEXP_CONTAINS(sw_code, r<span>"</span></span>.oncanmakepayments<span>*</span><span>=</span>|addEventListener(s<span>*</span>[<span><span>"</span>']canmakepayment[<span>"</span></span><span><span>'</span>]") AS canmakepayment_event,</span>
<span>  REGEXP_CONTAINS(sw_code, r"<span>.</span>onpaymentrequest<span>s</span>*=|addEventListener<span>(s</span>*[<span>"</span><span>'</span></span>]paymentrequest[<span><span>"</span>']<span>"</span></span>) <span>AS</span> paymentrequest_event,
  REGEXP_CONTAINS(sw_code, r<span><span>"</span>.onmessages*=|addEventListener(s*[<span>"</span></span><span><span>'</span>]message[<span>"</span><span>'</span></span>]<span><span>"</span>) AS message_event,</span>
<span>  REGEXP_CONTAINS(sw_code, r<span>"</span></span>.onmessageerrors<span>*</span><span>=</span>|addEventListener(s<span>*</span>[<span><span>"</span>']messageerror[<span>"</span></span><span><span>'</span>]") AS messageerror_event,</span>
<span>  REGEXP_CONTAINS(sw_code, r"new Workbox|new workbox|workbox<span>.</span>precaching<span>.</span>|workbox<span>.</span>strategies<span>.</span>") AS uses_workboxjs</span>
<span>FROM</span>
<span>  `progressive_web_apps.pwa_candidates`</span>
<span>JOIN (</span>
<span>  SELECT</span>
<span>    url,</span>
<span>    body AS sw_code,</span>
<span>    REGEXP_REPLACE(REGEXP_EXTRACT(_TABLE_SUFFIX, "<span>\</span>d{4}(?:_<span>\</span>d{2}){2}"), "_", "-") AS date,</span>
<span>    REGEXP_EXTRACT(_TABLE_SUFFIX, ".*_(<span>\</span>w+)$") AS platform</span>
<span>  FROM</span>
<span>    `httparchive.response_bodies.*`</span>
<span>  WHERE</span>
<span>    body IS NOT NULL</span>
<span>    AND body != ""</span>
<span>    AND url IN (</span>
<span>    SELECT</span>
<span>      DISTINCT sw_url</span>
<span>    FROM</span>
<span>      `progressive_web_apps.pwa_candidates`) ) AS sw_bodies</span>
<span>ON</span>
<span>  sw_bodies.url = sw_url</span>
<span>ORDER BY</span>
<span>  rank ASC,</span>
<span>  pwa_url,</span>
<span>  date DESC,</span>
<span>  platform,</span>
<span>  sw_url;</span></pre>
</div>
<h6><a></a>Research Ideas</h6>
<p>
  Having detailed service worker data allows for interesting analyses. For
  example, we can use this data to track Workbox usage over time.
</p>
<div>
  <pre><span><span>#</span>standardSQL</span>
<span>SELECT</span>
  <span>date</span>,
  <span>count</span> (uses_workboxjs) <span>AS</span> total_uses_workbox
<span>FROM</span>
  <span><span>`</span>progressive_web_apps.service_workers<span>`</span></span>
<span>WHERE</span>
  uses_workboxjs
  <span>AND</span> platform <span>=</span> <span><span>'</span>mobile<span>'</span></span>
<span>GROUP BY</span>
  <span>date</span>
<span>ORDER BY</span>
  <span>date</span>;</pre>
</div>
<p>
  <a href="/images/image_4.png" target="_blank"
    ><img
      width="1200"
      height="742"
      src="/images/image_4.png"
      alt="Workbox usage over time, the trend is going up from ~1 in August 2017 to ~46 in June 2018"
  /></a>
</p>
<p>
  Lines of code (LOC) is a great metric (<a
    href="https://en.wikipedia.org/wiki/Source_lines_of_code#Utility"
    rel="nofollow"
    >not</a
  >) to estimate a team's productivity and to predict a task's complexity. Let's
  analyze the development of a given site's service worker in terms of string
  length. Seems like the team deserves a raise‚Ä¶ üòâ
</p>
<div>
  <pre><span><span>#</span>standardSQL</span>
<span>SELECT</span>
  DISTINCT pwa_url,
  sw_url,
  <span>date</span>,
  CHAR_LENGTH(body) <span>AS</span> sw_length
<span>FROM</span>
  <span><span>`</span>progressive_web_apps.service_workers<span>`</span></span>
<span>JOIN</span>
  <span><span>`</span>httparchive.response_bodies.*<span>`</span></span>
<span>ON</span>
  sw_url <span>=</span> url
  <span>AND</span> <span>date</span> <span>=</span> REGEXP_REPLACE(REGEXP_EXTRACT(_TABLE_SUFFIX, <span><span>"</span>\d{4}(?:_\d{2}){2}<span>"</span></span>), <span><span>"</span>_<span>"</span></span>, <span><span>"</span>-<span>"</span></span>)
  <span>AND</span> platform <span>=</span> REGEXP_EXTRACT(_TABLE_SUFFIX, <span><span>"</span>.*_(\w+)$<span>"</span></span>)
<span>WHERE</span>
  <span><span>#</span> Redacted</span>
  pwa_url <span>=</span> <span><span>"</span>https://example.com/<span>"</span></span>
  <span>AND</span> platform <span>=</span> <span><span>"</span>mobile<span>"</span></span>
<span>ORDER BY</span>
  <span>date</span> <span>ASC</span>;</pre>
</div>
<p>
  <a href="/images/image_5.png" target="_blank"
    ><img
      width="1200"
      height="742"
      src="/images/image_5.png"
      alt="String length of an anonymized site's service worker over time, the trend is going up from ~16,000 characters in March 2016 to ~28,000 characters in June 2018"
  /></a>
</p>
<p>
  A final idea is to examine service worker events over time and see if there
  are interesting developments. Something that stands out in the analysis is how
  increasingly the <code>fetch</code> event is being listened to as well as the
  <code>message</code> event. Both are an indicator for more complex offline
  handling scenarios.
</p>
<div>
  <pre><span><span>#</span>standardSQL</span>
<span>SELECT</span>
  <span>date</span>,
  <span>COUNT</span>(IF (install_event,
      TRUE,
      <span>NULL</span>)) <span>AS</span> install_events,
  <span>COUNT</span>(IF ( activate_event,
      TRUE,
      <span>NULL</span>)) <span>AS</span> activate_events,
  <span>COUNT</span>(IF ( fetch_event,
      TRUE,
      <span>NULL</span>)) <span>AS</span> fetch_events,
  <span>COUNT</span>(IF ( push_event,
      TRUE,
      <span>NULL</span>)) <span>AS</span> push_events,
  <span>COUNT</span>(IF ( notificationclick_event,
      TRUE,
      <span>NULL</span>)) <span>AS</span> notificationclick_events,
  <span>COUNT</span>(IF ( notificationclose_event,
      TRUE,
      <span>NULL</span>)) <span>AS</span> notificationclose_events,
  <span>COUNT</span>(IF ( sync_event,
      TRUE,
      <span>NULL</span>)) <span>AS</span> sync_events,
  <span>COUNT</span>(IF ( canmakepayment_event,
      TRUE,
      <span>NULL</span>)) <span>AS</span> canmakepayment_events,
  <span>COUNT</span>(IF ( paymentrequest_event,
      TRUE,
      <span>NULL</span>)) <span>AS</span> paymentrequest_events,
  <span>COUNT</span>(IF ( message_event,
      TRUE,
      <span>NULL</span>)) <span>AS</span> message_events,
  <span>COUNT</span>(IF ( messageerror_event,
      TRUE,
      <span>NULL</span>)) <span>AS</span> messageerror_events
<span>FROM</span>
  <span><span>`</span>progressive_web_apps.service_workers<span>`</span></span>
<span>WHERE</span>
  NOT uses_workboxjs
  <span>AND</span> <span>date</span> <span>LIKE</span> <span><span>"</span>2018-%<span>"</span></span>
<span>GROUP BY</span>
  <span>date</span>
<span>ORDER BY</span>
  <span>date</span>;</pre>
</div>
<p>
  <a href="/images/image_6.png" target="_blank"
    ><img
      width="1200"
      height="742"
      src="/images/image_6.png"
      alt="Service worker events over time, showing an increasing usage of the fetch and the message event from February to June 2018"
  /></a>
</p>
<h4><a></a>Meta Approach: <em>Approaches 1¬ñ3</em> Combined</h4>
<p>
  An interesting meta analysis is to combine all approaches to get a feeling for
  the overall landscape of PWAs in the HTTP Archive (with all aforementioned
  pros and cons regarding precision and recall applied). If we run the query
  below, we find exactly
  <a
    href="https://docs.google.com/spreadsheets/d/1XcSa59AwZZiqz7QdEH6CncU6lnSgzAEAOMbyI-aHBow/edit?usp=sharing"
    rel="nofollow"
    >6,647 unique PWAs</a
  >. They may not necessarily still be PWAs today; some of the previously very
  prominent PWA lighthouse cases are known to have regressed, and some were only
  very briefly experimenting with the technologies, but in the HTTP Archive we
  have evidence of the glory moment in history where all of these pages
  fulfilled at least one of our three approaches' criteria for being counted as
  a PWA.
</p>
<div>
  <pre><span><span>#</span>standardSQL</span>
<span>SELECT</span>
  DISTINCT pwa_url,
  rank
<span>FROM</span> (
  <span>SELECT</span>
    DISTINCT pwa_url,
    rank
  <span>FROM</span>
    <span><span>`</span>progressive_web_apps.lighthouse_pwas<span>`</span></span> <span>union all</span>
  <span>SELECT</span>
    DISTINCT pwa_url,
    rank
  <span>FROM</span>
    <span><span>`</span>progressive_web_apps.service_workers<span>`</span></span> <span>union all</span>
  <span>SELECT</span>
    DISTINCT pwa_url,
    rank
  <span>FROM</span>
    <span><span>`</span>progressive_web_apps.usecounters_pwas<span>`</span></span>)
<span>ORDER BY</span>
  rank <span>ASC</span>;</pre>
</div>
<p>
  If we aggregate by dates and ignore some runaway values, we can see linear
  growth in the total number of PWAs, with a slight decline at the end of our
  observation period that we will have an eye on in future research.
</p>
<div>
  <pre><span><span>#</span>standardSQL</span>
<span>SELECT</span>
  DISTINCT <span>date</span>,
  <span>COUNT</span>(pwa_url) <span>AS</span> pwas
<span>FROM</span> (
  <span>SELECT</span>
    DISTINCT <span>date</span>,
    pwa_url
  <span>FROM</span>
    <span><span>`</span>progressive_web_apps.lighthouse_pwas<span>`</span></span>
  <span>UNION ALL</span>
  <span>SELECT</span>
    DISTINCT <span>date</span>,
    pwa_url
  <span>FROM</span>
    <span><span>`</span>progressive_web_apps.service_workers<span>`</span></span>
  <span>UNION ALL</span>
  <span>SELECT</span>
    DISTINCT <span>date</span>,
    pwa_url
  <span>FROM</span>
    <span><span>`</span>progressive_web_apps.usecounters_pwas<span>`</span></span>)
<span>GROUP BY</span>
  <span>date</span>
<span>ORDER BY</span>
  <span>date</span>;</pre>
</div>
<p>
  <a href="/images/image_7.png" target="_blank"
    ><img
      width="1200"
      height="742"
      src="/images/image_7.png"
      alt="PWAs over time showing linear growth from February 2017 to June 2018, with a slight decline in May and June 2018"
  /></a>
</p>
<h4><a></a>Future Work and Conclusions</h4>
<p>
  In this document, we have presented three different approaches to extracting
  PWA data from the HTTP Archive. Each has its individual pros and cons, but
  especially <em>Approach 3</em> has proven very interesting as a basis for
  further analyses. All presented queries are evergreen in a sense that they are
  not tied to a particular crawl's tables, allowing for ongoing analyses also in
  the future. Depending on people's interest, we will see to what extent the
  data can be made generally available as part of the HTTP Archive's public
  tables. There are likewise interesting research opportunities by combining our
  results with the
  <a
    href="https://developers.google.com/web/tools/chrome-user-experience-report/"
    rel="nofollow"
    >Chrome User Experience Report</a
  >
  that is also
  <a
    href="https://developers.google.com/web/tools/chrome-user-experience-report/getting-started#query-dataset"
    rel="nofollow"
    >accessible with BigQuery</a
  >. Concluding, the overall trends show in the right direction. More and more
  pages are controlled by a service worker, leading to PWAs with a generally
  increasing Lighthouse PWA score. Something to watch out for is the decline in
  PWAs observed in the <em>Meta Approach</em>, which, however, is not reflected
  in the most precise and neutral <em>Approach 2</em>, where rather the opposite
  is the case. We look forward to learning about new ways people make use of our
  research and to PWAs becoming more and more mainstream.
</p>
<h4><a></a>Acknowledgements</h4>
<p>
  In no particular order we would like to thank
  <a href="https://twitter.com/mathias" rel="nofollow">Mathias Bynens</a> for
  help with shaping one of the initial queries,
  <a href="https://twitter.com/kenjibaheux" rel="nofollow">Kenji Baheux</a> for
  pointers that led to <em>Approach 2</em>,
  <a href="https://twitter.com/rick_viscomi" rel="nofollow">Rick Viscomi</a> and
  <a href="https://twitter.com/patmeenan?lang=en" rel="nofollow"
    >Patrick Meenan</a
  >
  for general HTTP Archive help and the video series,
  <a href="https://twitter.com/jeffposnick" rel="nofollow">Jeff Posnick</a>,
  <a href="https://twitter.com/ade_oshineye" rel="nofollow">Ade Oshineye</a>,
  <a href="https://twitter.com/igrigorik" rel="nofollow">Ilya Grigorik</a>,
  <a href="https://twitter.com/JohnMu" rel="nofollow">John Mueller</a>,
  <a href="https://twitter.com/cheneytsai?lang=en" rel="nofollow">Cheney Tsai</a
  >,
  <a href="https://twitter.com/mcmd" rel="nofollow"
    >Miguel Carlos Mart√≠nez D√≠az</a
  >, and
  <a href="https://twitter.com/ebidel" rel="nofollow">Eric Bidelman</a> for
  editorial comments, as well as
  <a href="https://twitter.com/falkenmatto?lang=en" rel="nofollow"
    >Matt Falkenhagen</a
  >
  and <a href="https://twitter.com/mgiuca" rel="nofollow">Matt Giuca</a> for
  providing technical background on use counters.
</p>
